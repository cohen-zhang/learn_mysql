# 01 | 基础架构：一条SQL查询语句是如何执行的？

## 问题

1. MySQL 从V5.5.5版本后默认的存储引擎就是 InnoDB； 
2. MySQL 的两层逻辑架构图

![MySQL的两层逻辑架构图](https://static001.geekbang.org/resource/image/6f/1b/6f6b4a4b4d3b6b3b6b3b3b3b3b3b1b6f.png)

除了存储数据，提供读写接口在存储引擎层，还有一些额外的功能，比如权限管理、复制、备份等等。这些功能模块都在 Server 层实现，跟存储引擎没有关系。

### 1.1 连接器

```sql
-- 最常用的连接命令
mysql -h$ip -P$port -u$user -p
```

使用 `show processlist` 命令可以看到当前所有的连接，以及这些连接正在执行的命令。如果连接数太多，可以用 kill 命令来杀掉一些连接。

```sql
-- 查看当前连接, 以及正在执行的命令，给出 Query 、Sleep 、Killed 等状态的Demo
mysql> show processlist;
+----+------+-----------------+------+---------+------+-------+------------------+
| Id | User | Host            | db   | Command | Time | State | Info             |
+----+------+-----------------+------+---------+------+-------+------------------+
|  3 | root | localhost:49334 | NULL | Sleep   |  110 |       | NULL             |
|  4 | root | localhost:49335 | NULL | Sleep   |    3 |       | NULL             |
|  5 | root | localhost:49336 | NULL | Query   |    0 | init  | show processlist |
+----+------+-----------------+------+---------+------+-------+------------------+
3 rows in set (0.00 sec)
```

- Id：连接的线程ID。这个是MySQL自动生成的，每一个新连接的线程都会有一个唯一的ID。如果连接断了，线程会自动消失。
- User：连接所用的MySQL账户名。这个可能会和你登录MySQL的用户名不一致。因为MySQL有个偷懒的机制，允许你用一个账户名，连接成功之后，再通过 `mysql -u -p` 的方式，用其他账户名来操作。
- Host：连接的来源地址。这个可以帮助我们定位产生问题的客户端应用程序。如果是本机的话，就是 localhost 或者 
- db: 连接到的数据库。如果没有指定，则为 null。这个字段可以帮助我们区分，当前连接的目的是想要操作哪个数据库，如果没有指定，则表示还没有选择数据库。
- Command: 连接当前正在执行的命令。比如，如果是 `Sleep` 状态，说明当前连接正在等待客户端发送新的请求；如果是 `Query` 状态，说明当前连接正在执行查询语句；如果是 `Killed` 状态，说明当前连接被管理员用 `kill` 命令杀掉了，这个状态是最终态，线程也会随之消失。
- Time: 连接持续多长时间了，单位是秒。这个可以帮助我们分析，某个连接持续时间过长，是不是有什么问题。
- State: 连接的当前状态。比如，正在连接、连接成功、正在等待结果、正在发送数据等等。这个字段可以帮助我们定位问题，是网络繁忙导致的问题，还是查询语句写得有问题。
- Info: 连接当前正在执行的语句。如果是 `Sleep` 状态，这个字段是空的；如果是 `Query` 状态，就是当前正在执行的查询语句。

## 1.2 查询缓存

一句话：查询缓存（Query Cache）可以帮助我们提升查询的速度，但是它并不总是起作用。少用！

MySQL 8.0 版本已经把查询缓存的整块功能删掉了，因为这个功能本身有很多弊端，比如表更新之后，所有的缓存都失效，而且查询缓存的失效粒度很粗，很多时候一个小小的更新，就会导致很多缓存失效，最终导致缓存命中率很低。

### 1.3 分析器

分析器（Parser）会先拿到查询字符串，然后做解析，判断你的查询语句是否满足 MySQL 语法。如果你的查询语句不对，你会收到一个“你的SQL语句有语法错误”的报错。

比如，你在查询的时候，把 `from` 写成了 `form`，这时候分析器就会报错。

```sql
mysql> select * form T;
ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'form T' at line 1
```

### 1.4 优化器

优化器（Optimizer）是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。

```sql
-- 举例
select * from T where id = 10;
```

如果表 T 上有主键索引，那么就会选择主键索引去查询；
如果表 T 上没有主键索引，但是有一个唯一索引，那么就会选择这个唯一索引去查询；
如果表 T 上没有主键和唯一索引，但是有一个普通索引，那么就会选择这个普通索引去查询。
如果表 T 上没有任何索引，那么就会进行全表扫描。这个时候，如果表 T 的数据量很大，就会导致查询特别慢。

```sql
-- 举例
select * from T1 join T2 on T1.id = T2.id
where T1.k = 10 and T2.k between 50 and 100;
```

这个语句中，有两个表 T1 和 T2，这两个表都有字段 k，我们要查询的时候，需要同时对这两个表的 k 字段进行过滤，然后再做 join 操作。
那是先过滤表 T1 还是先过滤表 T2 呢？这个时候，优化器就会决定，先过滤哪个表。执行顺序不同，执行效率也会不同。

### 1.5 执行器

执行器（Executor）会先判断你对这个表 T 有没有执行查询的权限，如果没有，就会返回没有权限的错误，比如：

```sql
mysql> select * from T;
ERROR 1142 (42000): SELECT command denied to user 'test'@'localhost' for table 'T'
```

如果有权限，就会打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口。
执行器的流程如下：

1. 调用 InnoDB 引擎接口取这个表的第一行。根据表的定义，取出来的第一行应该是 id = 1 这一行。
2. 拿到这一行之后，判断一下这一行的 k 值是不是 10，如果不是，就跳过，直接取下一行。这一行不满足，那么就不符合我们的查询条件，不用返回给用户。
3. 如果这一行的 k 值是 10，那么就把这一行取出来，放到结果集里面。
4. 执行器重复上述过程，直到所有满足条件的行都放到结果集中，返回给客户端。
